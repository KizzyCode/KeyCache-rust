/* automatically generated by rust-bindgen 0.72.0 */

#[doc = " @brief A stack-allocated fixed-size buffer for data transfer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sep_buf_t {
    #[doc = " @brief The amount of bytes with `bytes`"]
    pub len: usize,
    #[doc = " @brief The buffer"]
    pub bytes: [u8; 2040usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sep_buf_t"][::std::mem::size_of::<sep_buf_t>() - 2048usize];
    ["Alignment of sep_buf_t"][::std::mem::align_of::<sep_buf_t>() - 8usize];
    ["Offset of field: sep_buf_t::len"][::std::mem::offset_of!(sep_buf_t, len) - 0usize];
    ["Offset of field: sep_buf_t::bytes"][::std::mem::offset_of!(sep_buf_t, bytes) - 8usize];
};
#[repr(u32)]
#[doc = " @brief The required permissions to use a key\n\n @warning All permissions are exclusive, you MUST NOT `or` them etc. – only use them as-is"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sep_permissions_t {
    #[doc = " @brief The device must at least be unlocked once after boot to access a key\n\n @warning All permissions are exclusive, you MUST NOT `or` them etc. – only use them as-is"]
    sep_permissions_needs_unlock_once = 1,
    #[doc = " @brief The device must be currently unlocked to access a key\n\n @warning All permissions are exclusive, you MUST NOT `or` them etc. – only use them as-is"]
    sep_permissions_needs_unlock = 2,
    #[doc = " @brief The user must authenticate to the device for each key usage\n\n @warning All permissions are exclusive, you MUST NOT `or` them etc. – only use them as-is"]
    sep_permissions_needs_interactive_auth = 3,
    #[doc = " @brief Needs biometric authentication for each key usage\n\n @warning All permissions are exclusive, you MUST NOT `or` them etc. – only use them as-is"]
    sep_permissions_needs_biometry = 4,
    #[doc = " @brief Needs the same biometric authentication that has been enrolled when the key was created for each key usage\n\n @warning All permissions are exclusive, you MUST NOT `or` them etc. – only use them as-is"]
    sep_permissions_needs_same_biometry = 5,
}
unsafe extern "C" {
    #[doc = " @brief Generates a new secure enclave backed P256 private key\n\n @param permissions The permissions to use a key (will be bound to the key and enforced by the secure enclave)\n @param key A buffer to write the sealed private key blob into (the blob is encrypted and tied to this secure enclave)\n @param error A buffer to write potential error information into\n @return int `0` on success or `-1` on error"]
    pub fn sep_p256_generate(
        permissions: sep_permissions_t,
        key: *mut sep_buf_t,
        error: *mut sep_buf_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Gets the associated public key in uncompressed SEC 1 representation (`0x04 || x || y`)\n\n @param key The sealed private key blob\n @param publickey A buffer to write the public key into\n @param error A buffer to write potential error information into\n @return int `0` on success or `-1` on error"]
    pub fn sep_p256_publickey(
        key: *const sep_buf_t,
        publickey: *mut sep_buf_t,
        error: *mut sep_buf_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Derives an ECDH shared secret in uncompressed SEC 1 representation (`0x04 || x || y`)\n\n @param key The sealed private key blob\n @param other The other party's public key in uncompressed SEC 1 representation (`0x04 || x || y`)\n @param dhsecret A buffer to write the ECDH shared secret into\n @param error A buffer to write potential error information into\n @return int `0` on success or `-1` on error"]
    pub fn sep_p256_keyexchange(
        key: *const sep_buf_t,
        other: *const sep_buf_t,
        dhsecret: *mut sep_buf_t,
        error: *mut sep_buf_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Generates an ECDSA signature for the given hash value in it's raw representation (`r || s`,\n        see https://tools.ietf.org/html/rfc4754)\n\n @param key The sealed private key blob\n @param hash The hash value to sign\n @param ecdsasig A buffer to write the ECDSA signature into\n @param error A buffer to write potential error information into\n @return int `0` on success or `-1` on error"]
    pub fn sep_p256_signhash(
        key: *const sep_buf_t,
        hash: *const sep_buf_t,
        ecdsasig: *mut sep_buf_t,
        error: *mut sep_buf_t,
    ) -> ::std::os::raw::c_int;
}
