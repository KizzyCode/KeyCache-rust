//! FFI adapter for `libSecureEnclave.dylib`

use libloading::Library;
use std::ffi::c_int;
use std::sync::OnceLock;

/// FFI bindings to the shipped `libsecureenclave`
///
/// ## ⚠️ HAZMAT – SAFETY ⚠️
/// This file is manually generated, and must always be kept in sync with the bundled submodule version to avoid
/// undefined behaviour.
mod libsecureenclave {
    #![allow(unused, reason = "Includes autogenerated bindings")]
    #![allow(non_snake_case, reason = "Includes autogenerated bindings")]
    #![allow(non_camel_case_types, reason = "Includes autogenerated bindings")]
    #![allow(non_upper_case_globals, reason = "Includes autogenerated bindings")]
    include!("libsecureenclave.rs");
}

// Re-export FFI types
pub use libsecureenclave::{sep_buf_t, sep_permissions_t};

/// FFI adapter for `libSecureEnclave.dylib`
#[derive(Debug)]
pub struct LibSecureEnclave {
    /// See [`libsecureenclave::sep_p256_generate_t`]
    pub sep_p256_generate:
        unsafe extern "C" fn(permissions: sep_permissions_t, key: *mut sep_buf_t, error: *mut sep_buf_t) -> c_int,
    /// See [`libsecureenclave::sep_p256_publickey_t`]
    pub sep_p256_publickey:
        unsafe extern "C" fn(key: *const sep_buf_t, publickey: *mut sep_buf_t, error: *mut sep_buf_t) -> c_int,
    /// See [`libsecureenclave::sep_p256_keyexchange_t`]
    pub sep_p256_keyexchange: unsafe extern "C" fn(
        key: *const sep_buf_t,
        other: *const sep_buf_t,
        dhsecret: *mut sep_buf_t,
        error: *mut sep_buf_t,
    ) -> c_int,
    /// See [`libsecureenclave::sep_p256_signhash_t`]
    pub sep_p256_signhash: unsafe extern "C" fn(
        key: *const sep_buf_t,
        hash: *const sep_buf_t,
        ecdsasig: *mut sep_buf_t,
        error: *mut sep_buf_t,
    ) -> c_int,
}
impl LibSecureEnclave {
    /// Loads the FFI adapter from the given library handle
    ///
    /// # Panic
    /// This function panics if the library does not contain the expected symbols.
    ///
    /// # Safety
    /// This function expects that the correct dylib is passed, and the loaded symbos have the correct expected types.
    pub(crate) unsafe fn load(lib: &'static Library) -> &'static Self {
        /// Cache this instance so we don't load the symbols on every access
        static LIBRARY: OnceLock<LibSecureEnclave> = OnceLock::new();
        LIBRARY.get_or_init(|| Self {
            // Load function symbols from dylib
            sep_p256_generate: *unsafe { lib.get(b"sep_p256_generate\0") }.expect("failed to load symbol"),
            sep_p256_publickey: *unsafe { lib.get(b"sep_p256_publickey\0") }.expect("failed to load symbol"),
            sep_p256_keyexchange: *unsafe { lib.get(b"sep_p256_keyexchange\0") }.expect("failed to load symbol"),
            sep_p256_signhash: *unsafe { lib.get(b"sep_p256_signhash\0") }.expect("failed to load symbol"),
        })
    }
}
