//! This crate provides a sys-wrapper for <https://github.com/KizzyCode/secureenclave-c>.

use libloading::Library;
use std::env;
use std::ffi::{CStr, OsStr, c_int};
use std::fs::{self, File};
use std::io::Write;
use std::os::fd::FromRawFd;
use std::os::unix::ffi::{OsStrExt, OsStringExt};
use std::sync::{LazyLock, OnceLock};

/// The binary contents of the dylib for dynamic installation
pub const DYLIB_BIN: &[u8] = include_bytes!(env!("LIBSECUREENCLAVE_DYLIB_PATH"));

/// FFI bindings to the shipped `libsecureenclave`
///
/// ## ⚠️ HAZMAT – SAFETY ⚠️
/// The bindings are manually generated, and must always be kept in sync with the bundled submodule version to avoid
/// undefined behaviour.
mod libsecureenclave {
    #![allow(unused, reason = "Includes autogenerated bindings")]
    #![allow(non_snake_case, reason = "Includes autogenerated bindings")]
    #![allow(non_camel_case_types, reason = "Includes autogenerated bindings")]
    #![allow(non_upper_case_globals, reason = "Includes autogenerated bindings")]
    include!("libsecureenclave.rs");
}

// Re-export FFI types
pub use libsecureenclave::{sep_buf_t, sep_permissions_t};

/// FFI adapter for `libSecureEnclave.dylib`
#[derive(Debug)]
pub struct LibSecureEnclave {
    /// See [`libsecureenclave::sep_p256_generate`]
    pub sep_p256_generate:
        unsafe extern "C" fn(permissions: sep_permissions_t, key: *mut sep_buf_t, error: *mut sep_buf_t) -> c_int,
    /// See [`libsecureenclave::sep_p256_publickey`]
    pub sep_p256_publickey:
        unsafe extern "C" fn(key: *const sep_buf_t, publickey: *mut sep_buf_t, error: *mut sep_buf_t) -> c_int,
    /// See [`libsecureenclave::sep_p256_keyexchange`]
    pub sep_p256_keyexchange: unsafe extern "C" fn(
        key: *const sep_buf_t,
        other: *const sep_buf_t,
        dhsecret: *mut sep_buf_t,
        error: *mut sep_buf_t,
    ) -> c_int,
    /// See [`libsecureenclave::sep_p256_signhash`]
    pub sep_p256_signhash: unsafe extern "C" fn(
        key: *const sep_buf_t,
        hash: *const sep_buf_t,
        ecdsasig: *mut sep_buf_t,
        error: *mut sep_buf_t,
    ) -> c_int,
}
impl LibSecureEnclave {
    /// Loads the FFI adapter from the given library handle
    ///
    /// # Panic
    /// This function panics if the library does not contain the expected symbols.
    ///
    /// # Safety
    /// This function expects that the correct dylib is passed, and the loaded symbos have the correct expected types.
    pub unsafe fn load() -> &'static Self {
        /// Static lazy library handle
        static LIBRARY: LazyLock<Library> = LazyLock::new(|| {
            // Create tempfile
            let tempfile_path = env::temp_dir().join("libsecureenclave-XXXXXX.dylib\0");
            let mut tempfile_path = tempfile_path.into_os_string().into_vec();
            let tempfile_fd = unsafe { libc::mkstemps(tempfile_path.as_mut_ptr() as _, ".dylib".len() as _) };
            assert!(tempfile_fd > 0, "failed to create tempfile");

            // Write library to tempfile
            let mut tempfile = unsafe { File::from_raw_fd(tempfile_fd) };
            tempfile.write_all(DYLIB_BIN).expect("failed to write dylib to tempfile");

            // Convert the tempfile back into a usable path, and load dylib
            let tempfile_path =
                CStr::from_bytes_until_nul(&tempfile_path).expect("`mkstemps` assembled invalid tempfile path");
            let tempfile_path = OsStr::from_bytes(tempfile_path.to_bytes());
            let library = unsafe { Library::new(&tempfile_path).expect("failed to load dylib from tempfile") };

            // Unlink tempfile and return library handle
            fs::remove_file(tempfile_path).expect("failed to delete tempfile");
            library
        });

        /// Cache this instance so we don't load the symbols on every access
        static THIS: OnceLock<LibSecureEnclave> = OnceLock::new();
        THIS.get_or_init(|| Self {
            // Load function symbols from dylib
            sep_p256_generate: *unsafe { LIBRARY.get(b"sep_p256_generate\0") }.expect("failed to load symbol"),
            sep_p256_publickey: *unsafe { LIBRARY.get(b"sep_p256_publickey\0") }.expect("failed to load symbol"),
            sep_p256_keyexchange: *unsafe { LIBRARY.get(b"sep_p256_keyexchange\0") }.expect("failed to load symbol"),
            sep_p256_signhash: *unsafe { LIBRARY.get(b"sep_p256_signhash\0") }.expect("failed to load symbol"),
        })
    }
}
